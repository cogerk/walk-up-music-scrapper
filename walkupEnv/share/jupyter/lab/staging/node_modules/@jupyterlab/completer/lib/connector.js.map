{"version":3,"file":"connector.js","sourceRoot":"","sources":["../../../../completer/src/connector.ts"],"names":[],"mappings":";AAAA,0CAA0C;AAC1C,2DAA2D;;AAE3D,qDAAsD;AAEtD,uDAAoD;AAEpD,yDAAsD;AAItD;;GAEG;AACH,yBAAiC,SAAQ,yBAIxC;IACC;;;;OAIG;IACH,YAAY,OAAqC;QAC/C,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,IAAI,iCAAe,CAAC,OAAO,CAAC,CAAC;QAC5C,IAAI,CAAC,QAAQ,GAAG,IAAI,mCAAgB,CAAC,OAAO,CAAC,CAAC;IAChD,CAAC;IAED;;;;OAIG;IACH,KAAK,CACH,OAAmC;QAEnC,OAAO,OAAO,CAAC,GAAG,CAAC;YACjB,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC;YAC3B,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,OAAO,CAAC;SAC7B,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,WAAW,EAAE,YAAY,CAAC,EAAE,EAAE;YACtC,OAAO,OAAO,CAAC,YAAY,CAAC,WAAW,EAAE,YAAY,CAAC,CAAC;QACzD,CAAC,CAAC,CAAC;IACL,CAAC;CAIF;AAlCD,kDAkCC;AAYD;;GAEG;AACH,IAAU,OAAO,CAyBhB;AAzBD,WAAU,OAAO;IACf;;OAEG;IACH,sBACE,MAAgC,EAChC,OAAiC;QAEjC,qCAAqC;QACrC,IAAI,MAAM,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;YAC/B,OAAO,OAAO,CAAC;SAChB;aAAM,IAAI,OAAO,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;YACvC,OAAO,MAAM,CAAC;SACf;QAED,mEAAmE;QACnE,iBAAiB;QACjB,IAAI,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;QACrC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YAC9B,IAAI,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;gBACjC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;aACrB;QACH,CAAC,CAAC,CAAC;QACH,yBAAY,MAAM,IAAE,OAAO,IAAG;IAChC,CAAC;IApBe,oBAAY,eAoB3B,CAAA;AACH,CAAC,EAzBS,OAAO,KAAP,OAAO,QAyBhB","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { DataConnector } from '@jupyterlab/coreutils';\n\nimport { KernelConnector } from './kernelconnector';\n\nimport { ContextConnector } from './contextconnector';\n\nimport { CompletionHandler } from './handler';\n\n/**\n * A context+kernel connector for completion handlers.\n */\nexport class CompletionConnector extends DataConnector<\n  CompletionHandler.IReply,\n  void,\n  CompletionHandler.IRequest\n> {\n  /**\n   * Create a new connector for completion requests.\n   *\n   * @param options - The instatiation options for the connector.\n   */\n  constructor(options: CompletionConnector.IOptions) {\n    super();\n    this._kernel = new KernelConnector(options);\n    this._context = new ContextConnector(options);\n  }\n\n  /**\n   * Fetch completion requests.\n   *\n   * @param request - The completion request text and details.\n   */\n  fetch(\n    request: CompletionHandler.IRequest\n  ): Promise<CompletionHandler.IReply> {\n    return Promise.all([\n      this._kernel.fetch(request),\n      this._context.fetch(request)\n    ]).then(([kernelReply, contextReply]) => {\n      return Private.mergeReplies(kernelReply, contextReply);\n    });\n  }\n\n  private _kernel: KernelConnector;\n  private _context: ContextConnector;\n}\n\n/**\n * A namespace for completion connector statics.\n */\nexport namespace CompletionConnector {\n  /**\n   * The instantiation options for cell completion handlers.\n   */\n  export type IOptions = KernelConnector.IOptions & ContextConnector.IOptions;\n}\n\n/**\n * A namespace for private functionality.\n */\nnamespace Private {\n  /**\n   * Merge results from kernel and context completions.\n   */\n  export function mergeReplies(\n    kernel: CompletionHandler.IReply,\n    context: CompletionHandler.IReply\n  ): CompletionHandler.IReply {\n    // If one is empty, return the other.\n    if (kernel.matches.length === 0) {\n      return context;\n    } else if (context.matches.length === 0) {\n      return kernel;\n    }\n\n    // They both have matches, so merge them, with a preference for the\n    // kernel result.\n    let matches = kernel.matches.slice();\n    context.matches.forEach(match => {\n      if (matches.indexOf(match) === -1) {\n        matches.push(match);\n      }\n    });\n    return { ...kernel, matches };\n  }\n}\n"]}