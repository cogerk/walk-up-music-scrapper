{"version":3,"file":"contextconnector.js","sourceRoot":"","sources":["../../../../completer/src/contextconnector.ts"],"names":[],"mappings":";AAAA,0CAA0C;AAC1C,2DAA2D;;AAI3D,qDAAsD;AAItD;;GAEG;AACH,sBAA8B,SAAQ,yBAIrC;IACC;;;;OAIG;IACH,YAAY,OAAkC;QAC5C,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC;IAChC,CAAC;IAED;;;;OAIG;IACH,KAAK,CACH,OAAmC;QAEnC,OAAO,IAAI,OAAO,CAA2B,OAAO,CAAC,EAAE;YACrD,OAAO,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;QAC7C,CAAC,CAAC,CAAC;IACL,CAAC;CAGF;AA7BD,4CA6BC;AAiBD;;GAEG;AACH,IAAU,OAAO,CA4ChB;AA5CD,WAAU,OAAO;IACf;;;OAGG;IACH,qBACE,MAA0B;QAE1B,+BAA+B;QAC/B,MAAM,MAAM,GAAG,MAAM,CAAC,iBAAiB,EAAE,CAAC;QAC1C,MAAM,KAAK,GAAG,MAAM,CAAC,mBAAmB,CAAC,MAAM,CAAC,CAAC;QAEjD,mCAAmC;QACnC,MAAM,SAAS,GAAG,mBAAmB,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;QAErD,kDAAkD;QAClD,6CAA6C;QAC7C,MAAM,cAAc,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;QACvE,8CAA8C;QAC9C,MAAM,OAAO,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,GAAG,CAAS,cAAc,CAAC,CAAC,CAAC;QAE5D,OAAO;YACL,KAAK,EAAE,KAAK,CAAC,MAAM;YACnB,GAAG,EAAE,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM;YACtC,OAAO;YACP,QAAQ,EAAE,EAAE;SACb,CAAC;IACJ,CAAC;IAtBe,mBAAW,cAsB1B,CAAA;IAED;;;OAGG;IACH,6BACE,KAAwB,EACxB,MAA0B;QAE1B,MAAM,UAAU,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;QACtC,oDAAoD;QACpD,qBAAqB;QACrB,OAAO,UAAU,CAAC,MAAM,CACtB,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,KAAK,KAAK,KAAK,CAAC,KAAK,CACnE,CAAC;IACJ,CAAC;AACH,CAAC,EA5CS,OAAO,KAAP,OAAO,QA4ChB","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { CodeEditor } from '@jupyterlab/codeeditor';\n\nimport { DataConnector } from '@jupyterlab/coreutils';\n\nimport { CompletionHandler } from './handler';\n\n/**\n * A context connector for completion handlers.\n */\nexport class ContextConnector extends DataConnector<\n  CompletionHandler.IReply,\n  void,\n  CompletionHandler.IRequest\n> {\n  /**\n   * Create a new context connector for completion requests.\n   *\n   * @param options - The instatiation options for the context connector.\n   */\n  constructor(options: ContextConnector.IOptions) {\n    super();\n    this._editor = options.editor;\n  }\n\n  /**\n   * Fetch completion requests.\n   *\n   * @param request - The completion request text and details.\n   */\n  fetch(\n    request: CompletionHandler.IRequest\n  ): Promise<CompletionHandler.IReply> {\n    return new Promise<CompletionHandler.IReply>(resolve => {\n      resolve(Private.contextHint(this._editor));\n    });\n  }\n\n  private _editor: CodeEditor.IEditor;\n}\n\n/**\n * A namespace for context connector statics.\n */\nexport namespace ContextConnector {\n  /**\n   * The instantiation options for cell completion handlers.\n   */\n  export interface IOptions {\n    /**\n     * The session used by the context connector.\n     */\n    editor: CodeEditor.IEditor;\n  }\n}\n\n/**\n * A namespace for Private functionality.\n */\nnamespace Private {\n  /**\n   * Get a list of completion hints from a tokenization\n   * of the editor.\n   */\n  export function contextHint(\n    editor: CodeEditor.IEditor\n  ): CompletionHandler.IReply {\n    // Find the token at the cursor\n    const cursor = editor.getCursorPosition();\n    const token = editor.getTokenForPosition(cursor);\n\n    // Get the list of matching tokens.\n    const tokenList = getCompletionTokens(token, editor);\n\n    // Only choose the ones that have a non-empty type\n    // field, which are likely to be of interest.\n    const completionList = tokenList.filter(t => t.type).map(t => t.value);\n    // Remove duplicate completsions from the list\n    const matches = Array.from(new Set<string>(completionList));\n\n    return {\n      start: token.offset,\n      end: token.offset + token.value.length,\n      matches,\n      metadata: {}\n    };\n  }\n\n  /**\n   * Get a list of tokens that match the completion request,\n   * but are not identical to the completion request.\n   */\n  function getCompletionTokens(\n    token: CodeEditor.IToken,\n    editor: CodeEditor.IEditor\n  ): CodeEditor.IToken[] {\n    const candidates = editor.getTokens();\n    // Only get the tokens that have a common start, but\n    // are not identical.\n    return candidates.filter(\n      t => t.value.indexOf(token.value) === 0 && t.value !== token.value\n    );\n  }\n}\n"]}